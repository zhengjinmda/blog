## 词法作用域和动态作用域
### 作用域
作用域是指：程序源代码中定义变量的区域。<br>
作用域规定了如何查找变量，也就是确定了当前执行代码对变量的访问权限。<br>
js 采用了词法作用域，也就是静态作用域。

### 静态作用域和动态作用域
js 采用的是词法作用域 函数的作用域在函数定义的时候就决定了。<br>
而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。
```js
// eg:
var value = 1
function foo() {
    console.log(value)
}
function bar() {
    var value = 2
    foo()
}

bar()
```
静态作用域/词法作用域：<br>
执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value ，如果没有，就根据书写的位置，去他上一层的代码，也就是 value = 1， 结果会打印 1。<br>
动态作用域：<br>
执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value ，如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，打印 2 。<br>
但是 js 使用的是 词法作用域， 所以打印 1。

### 思考题
```js
var scope = 'global scope'
function checkScope() {
    var scope = 'local scope'
    function f() {
        return scope
    }
    return f()
}

checkScope()
```
```js
var scope = 'global scope'
function checkScope() {
    var scope = 'local scope'
    function f() {
        return scope
    }
    return f
}
checkScope()()
```

以上两段代码执行的结果都是 `local scope`, 因为 js 是词法作用域，函数的作用域基于函数创建的位置。<br>
而 JavaScript 权威指南的 回答是：
JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的，嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。