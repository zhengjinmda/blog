## 作用域链
当 js 执行一段可执行的代码的时候，会创建对应的执行上下文。<br>
对于每个执行上下文，都有三个重要的属性：
1. 变量对象 (VO)
2. 作用域链
3. this

### 作用域链
在查找变量的时候，会先从当前上下文的变量对象中查找，如果没有知道，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。
### 函数创建
因为 js 使用词法作用域，函数的作用域在函数定义的时候就决定了。<br>
这是因为函数有一个内部属性 `[[scope]]` ,当函数创建的时候，就会保存所有父变量对象到其中。可以理解 `[[scope]]` 就是所有父变量对象的层级链，但是注意：`[[scope]]` 并不代表完整的作用域链！<br>
eg:
```js
function foo() {
    function bar() {
        ...
    }
}
```
函数创建时，各自的 `[[scope]]` 为：
```js
foo.[[scope]] = [
    globalContext.VO
]

bar.[[scope]] = [
    fooContext.AO,
    golobalContext.VO
]
```
### 函数激活
当函数激活时，进入函数上下文，创建了 VO / AO 后，就会将活动对象添加到作用域前端链。这时候执行上下文的作用域链，我们命名为Scope：
```js
Scope = [AO].concat([Scope])
```
作用域创建完毕
### 捋一捋
以下面例子为例，结合之前讲的变量对象和执行上下文栈，总结一下函数执行上下文中作用域链和变量的创建过程：
```js
var scope = 'global scope'
function checkScope() {
    var scope2 = 'local scope'
    return scope2
}
checkScope()
```
执行过程如下：
1. checkScope 函数被创建，保存作用域到内部属性`[[scope]]`
```js
checkScope.[[scope]] = [
    globalContext.VO
]
```
2. 执行 checkScope 创建，创建 checkScope 函数执行上下文，checkScope 函数执行上下文被压入执行上下文栈：
```js
ECStack = [
    checkScopeContext,
    globalContext
]
```
3. checkScope 并不立即执行， 开始做准备工作 第一步. 复制函数 `[[scope]]` 属性创建作用域链。
```js
checkScopeContext = [
    Scope: checkscope.[[scope]],
]
```
4. 第二步： 用 arguments 创建活动对象，随后初始化活动对象，加入形参 函数声明 变量声明。
```js
checkScopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    },
    Scope: checkScope.[[scope]]
}
```
5. 第三步 将活动对象压入 checkScope 作用域链顶端
```js
checkScopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    },
    Scope: [AO, [[Scope]]]
}
```
6. 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值
```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: 'local scope'
    },
    Scope: [AO, [[Scope]]]
}
```
7. 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出
```js
ECStack = [
    globalContext
];
```