## 变量、作用域与内存

### 确定类型
#### typeof
typeof可以判断一个变量是否为原始类型(undefined NaN string number boolean Symbol) 如果是null或者是对象， typeof 返回 object

#### instanceof
为了解决 typeof 无法判断 object 具体的类型，js有 instanceof来检测object， instanceof 检测原始值都返回false
```js
person instanceof Object
color instanceof Array
pattern instanceof RegExp
```

#### 执行上下文与作用域
见 js 语法


#### 作用域声明
var let const 

#### 标识符查找
在搜索过程中引用局部作用域变量让搜索自动停止，不继续搜索下一级变量对象。

#### 辣鸡回收
js 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在 c 和 c++ 中，跟踪内存使用对开发者来说是一个很大的负担，也是许多问题的来源。 js 为开发者卸下了这个负担，通过自动no内存管理实现内存分配和闲置资源回收。<br>
基本思路：确定哪个变量不会再使用，释放他占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行，垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。
---
1.标记清理<br>
2.引用计数<br>

#### 性能提升
使用不到的变量 可以赋值为 null 。



### 小结
js 变量可以保存两种类型的值：原始值和引用值。原始值可能是一下六种原始数据类型之一：undefined、null、string、number、boolean、Symbol。原始值和引用值有以下特点：
1. 原始值大小固定，因此保存在栈内存上。
2. 从一个变量到另一个变量复制原始值会创建该值的第二个副本。
3. 引用是对象，存储在堆内存中。
4. 包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。
5. 从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向一个对象。
6. typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。
任何变量（不管包含的是原始值还是引用值）都存在与某个执行上下文中（也称作用域）。这个上下文（作用域）决定了变量的生命周期，以及他们可以访问代码的哪些部分。执行上下文可以总结如下：
1. 执行上下文分全局上下文、函数上下文和块级上下文。
2. 代码执行流每进入一个新的上下文，都会创建一个作用域链，用来搜索函数和变量。
3. 函数或块的局部上下文不仅可以访问自己的作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文的变量。
4. 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文的任何数据。
5. 变量的执行上下文用于确定什么时候释放内存。
JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript的垃圾回收程序可总结如下：
1. 离开作用域的值会被自动标记为可回收，然后再垃圾回收期间被删除。
2. 主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收他们的内存。
3. 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript引擎不再使用这种算法，但某些旧版本的IE仍会受这种算法的影响，原因是JavaScript会访问非原生的JavaScript对象（如DOM）
4. 引用计数在代码中存在循环引用时会出现问题。
5. 解除变量的引用不仅可以消除循环引用。而且对垃圾回收也有帮助。为了促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除应用。