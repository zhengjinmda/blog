### 0.1 + 0.2 为什么不等于 0.3？
```js
var x = 0.1 + 0.2 // 0.30000000000000004
```

#### js 是如何表示数字的？
js 使用 Number 类型来表示数字（整数和浮点数） 通过 64 位来表示一个数字。
```js
符号位        指数部分（带偏移）       尾数部分
  0           1000.....01            001.........10
1位符号位s    11位的指数（带偏移）e     52位的尾数

所有数都可以表示成： 1.xxxxxxxxxxxxx * 2^n
```

1. 第0位：符号位，0表示正数，1表示负数(s)
2. 第1位到第11位：储存指数部分（e）
3. 第12位到第63位：储存小数部分（即有效数字）f

#### js 最大值
js最大安全数是 Number.MAX_SAFE_INTEGER == Math.pow(2,53) - 1, 而不是Math.pow(2,52) - 1, why？尾数部分不是只有52位吗?<br>
这是因为二进制表示有效数字总是1.xx…xx的形式，尾数部分f在规约形式下第一位默认为1（省略不写，xx..xx为尾数部分f，最长52位）。因此，JavaScript提供的有效数字最长为53个二进制位（64位浮点的后52位+被省略的1位）

#### 运算时发生了什么？
因为计算机无法直接对十进制的数字进行运算，所以需要先转化成二进制，然后对阶运算。<br>

##### 转化成二进制
```js
0.1 -> 0.0001100110011001...(无限循环)
0.2 -> 0.0011001100110011...(无限循环)
```
因为尾数52位的限制，所以在二进制转换的时候，精度会丢失掉。<br>
那为什么 x = 0.1 能得到 0.1 ？
这个是因为 0.1 不是真正的 0.1。。。。<br>
标准中规定尾数 f 的固定长度是 52 位，再加上省略的一位，这53位就是 js 精度范围。它最大可以表示2^53(9007199254740992), 长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理
```js
0.10000000000000000555.toPrecision(16)
// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1

// 但来一个更高的精度：
0.1.toPrecision(21) = 0.100000000000000005551
```
所以 0.1 = 0.1

##### 对阶运算(求补码和求阶差)
由于指数位数不相同，运算时需要对阶运算 这部分也可能产生精度损失
按照上面两步运算（包括两步的精度损失），最后的结果是
```js
0.0100110011001100110011001100110011001100110011001100 
```
所以：精度损失可能出现在进制转化和对阶运算过程中